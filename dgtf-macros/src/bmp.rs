
extern crate proc_macro;


use std::collections::HashMap;

use std::fs;
use tinybmp;
use tinybmp::ColorTable;
use embedded_graphics::{pixelcolor::Rgb888};



static PALETTE: [u8;768] = [
    0xFF, 0x00, 0xFF, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x17, 0x27, 0x17, 0x2F, 0x4F,
    0x2F, 0x47, 0x77, 0x47, 0x5F, 0x9F, 0x5F, 0x87,
    0xB7, 0x87, 0xAF, 0xCF, 0xAF, 0xD7, 0xE7, 0xD7,

    0x00, 0x00, 0x00, 0x0F, 0x2F, 0x0F, 0x1F, 0x5F,
    0x1F, 0x2F, 0x8F, 0x2F, 0x3F, 0xBF, 0x3F, 0x6F,
    0xCF, 0x6F, 0x9F, 0xDF, 0x9F, 0xCF, 0xEF, 0xCF,

    0x00, 0x00, 0x00, 0x07, 0x37, 0x07, 0x0F, 0x6F,
    0x0F, 0x17, 0xA7, 0x17, 0x1F, 0xDF, 0x1F, 0x57,
    0xE7, 0x57, 0x8F, 0xEF, 0x8F, 0xC7, 0xF7, 0xC7,

    0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x23, 0x27, 0x17, 0x47, 0x4F,
    0x2F, 0x6B, 0x77, 0x47, 0x8F, 0x9F, 0x5F, 0xAB,
    0xB7, 0x87, 0xC7, 0xCF, 0xAF, 0xE3, 0xE7, 0xD7,

    0x00, 0x00, 0x00, 0x27, 0x2F, 0x0F, 0x4F, 0x5F,
    0x1F, 0x77, 0x8F, 0x2F, 0x9F, 0xBF, 0x3F, 0xB7,
    0xCF, 0x6F, 0xCF, 0xDF, 0x9F, 0xE7, 0xEF, 0xCF,

    0x00, 0x00, 0x00, 0x2B, 0x37, 0x07, 0x57, 0x6F,
    0x0F, 0x83, 0xA7, 0x17, 0xAF, 0xDF, 0x1F, 0xC3,
    0xE7, 0x57, 0xD7, 0xEF, 0x8F, 0xEB, 0xF7, 0xC7,

    0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x27, 0x1F, 0x17, 0x4F, 0x3F,
    0x2F, 0x77, 0x5F, 0x47, 0x9F, 0x7F, 0x5F, 0xB7,
    0x9F, 0x87, 0xCF, 0xBF, 0xAF, 0xE7, 0xDF, 0xD7,

    0x00, 0x00, 0x00, 0x2F, 0x1F, 0x0F, 0x5F, 0x3F,
    0x1F, 0x8F, 0x5F, 0x2F, 0xBF, 0x7F, 0x3F, 0xCF,
    0x9F, 0x6F, 0xDF, 0xBF, 0x9F, 0xEF, 0xDF, 0xCF,

    0x00, 0x00, 0x00, 0x37, 0x1F, 0x07, 0x6F, 0x3F,
    0x0F, 0xA7, 0x5F, 0x17, 0xDF, 0x7F, 0x1F, 0xE7,
    0x9F, 0x57, 0xEF, 0xBF, 0x8F, 0xF7, 0xDF, 0xC7,

    0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x27, 0x17, 0x1B, 0x4F, 0x2F,
    0x37, 0x77, 0x47, 0x53, 0x9F, 0x5F, 0x6F, 0xB7,
    0x87, 0x93, 0xCF, 0xAF, 0xB7, 0xE7, 0xD7, 0xDB,

    0x00, 0x00, 0x00, 0x2F, 0x0F, 0x17, 0x5F, 0x1F,
    0x2F, 0x8F, 0x2F, 0x47, 0xBF, 0x3F, 0x5F, 0xCF,
    0x6F, 0x87, 0xDF, 0x9F, 0xAF, 0xEF, 0xCF, 0xD7,

    0x00, 0x00, 0x00, 0x37, 0x07, 0x13, 0x6F, 0x0F,
    0x27, 0xA7, 0x17, 0x3B, 0xDF, 0x1F, 0x4F, 0xE7,
    0x57, 0x7B, 0xEF, 0x8F, 0xA7, 0xF7, 0xC7, 0xD3,

    0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x27, 0x17, 0x27, 0x4F, 0x2F,
    0x4F, 0x77, 0x47, 0x77, 0x9F, 0x5F, 0x9F, 0xB7,
    0x87, 0xB7, 0xCF, 0xAF, 0xCF, 0xE7, 0xD7, 0xE7,

    0x00, 0x00, 0x00, 0x2F, 0x0F, 0x2F, 0x5F, 0x1F,
    0x5F, 0x8F, 0x2F, 0x8F, 0xBF, 0x3F, 0xBF, 0xCF,
    0x6F, 0xCF, 0xDF, 0x9F, 0xDF, 0xEF, 0xCF, 0xEF,

    0x00, 0x00, 0x00, 0x37, 0x07, 0x37, 0x6F, 0x0F,
    0x6F, 0xA7, 0x17, 0xA7, 0xDF, 0x1F, 0xDF, 0xE7,
    0x57, 0xE7, 0xEF, 0x8F, 0xEF, 0xF7, 0xC7, 0xF7,

    0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x1B, 0x17, 0x27, 0x37, 0x2F,
    0x4F, 0x53, 0x47, 0x77, 0x6F, 0x5F, 0x9F, 0x93,
    0x87, 0xB7, 0xB7, 0xAF, 0xCF, 0xDB, 0xD7, 0xE7,

    0x00, 0x00, 0x00, 0x17, 0x0F, 0x2F, 0x2F, 0x1F,
    0x5F, 0x47, 0x2F, 0x8F, 0x5F, 0x3F, 0xBF, 0x87,
    0x6F, 0xCF, 0xAF, 0x9F, 0xDF, 0xD7, 0xCF, 0xEF,

    0x00, 0x00, 0x00, 0x13, 0x07, 0x37, 0x27, 0x0F,
    0x6F, 0x3B, 0x17, 0xA7, 0x4F, 0x1F, 0xDF, 0x7B,
    0x57, 0xE7, 0xA7, 0x8F, 0xEF, 0xD3, 0xC7, 0xF7,

    0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x17, 0x1F, 0x27, 0x2F, 0x3F,
    0x4F, 0x47, 0x5F, 0x77, 0x5F, 0x7F, 0x9F, 0x87,
    0x9F, 0xB7, 0xAF, 0xBF, 0xCF, 0xD7, 0xDF, 0xE7,

    0x00, 0x00, 0x00, 0x0F, 0x1F, 0x2F, 0x1F, 0x3F,
    0x5F, 0x2F, 0x5F, 0x8F, 0x3F, 0x7F, 0xBF, 0x6F,
    0x9F, 0xCF, 0x9F, 0xBF, 0xDF, 0xCF, 0xDF, 0xEF,

    0x00, 0x00, 0x00, 0x07, 0x1F, 0x37, 0x0F, 0x3F,
    0x6F, 0x17, 0x5F, 0xA7, 0x1F, 0x7F, 0xDF, 0x57,
    0x9F, 0xE7, 0x8F, 0xBF, 0xEF, 0xC7, 0xDF, 0xF7,

    0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F,
    0x3F, 0x5F, 0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x9F,
    0x9F, 0x9F, 0xBF, 0xBF, 0xBF, 0xDF, 0xDF, 0xDF,

    0x00, 0x00, 0x00, 0x17, 0x27, 0x23, 0x2F, 0x4F,
    0x47, 0x47, 0x77, 0x6B, 0x5F, 0x9F, 0x8F, 0x87,
    0xB7, 0xAB, 0xAF, 0xCF, 0xC7, 0xD7, 0xE7, 0xE3,

    0x00, 0x00, 0x00, 0x0F, 0x2F, 0x27, 0x1F, 0x5F,
    0x4F, 0x2F, 0x8F, 0x77, 0x3F, 0xBF, 0x9F, 0x6F,
    0xCF, 0xB7, 0x9F, 0xDF, 0xCF, 0xCF, 0xEF, 0xE7,

    0x00, 0x00, 0x00, 0x07, 0x37, 0x2B, 0x0F, 0x6F,
    0x57, 0x17, 0xA7, 0x83, 0x1F, 0xDF, 0xAF, 0x57,
    0xE7, 0xC3, 0x8F, 0xEF, 0xD7, 0xC7, 0xF7, 0xEB,
];


fn palette_as_rgb888() -> Vec<Rgb888> {
    let mut palette = vec![];

    for color in PALETTE.chunks(3) {
        palette.push(Rgb888::new(color[0], color[1], color[2]))
    }

    palette
}

fn color_map() -> HashMap<Rgb888, u8> {
    let mut map = HashMap::new();

    let palette = palette_as_rgb888();

    for (i, color) in palette.iter().enumerate() {
        let h: u8 = (i / 32) as u8;
        let s: u8 = ((i % 32) / 8) as u8;
        let l: u8 = (i % 8) as u8;
        map.insert(color.clone(), (h << 5) | (s<< 3) | l);
    }

    map
}



fn derive_gametank_colors(color_table: &ColorTable) -> Vec<u8>{
    let mut colors = vec![];
    let color_map = color_map();

    for i in 0..color_table.len() {
        let color = color_table.get(i as u32).unwrap();
        // TODO: warn with closest color match instead of panicking
        colors.push(*color_map.get(&color).expect(&format!("{:?} does not exist in gametank color palette", color)));
    }

    colors.dedup();

    colors
}

fn pack_indices(indices: Vec<u8>, pixels_per_byte: u8) -> Vec<u8> {
    let bits_per_index = 8 / pixels_per_byte; // division here

    // chunk by pixels per byte
    // map each chunk to a single u8 by folding into an accumulator

    indices
        .chunks(pixels_per_byte as usize)
        .map(|chunk| {
            chunk.iter().enumerate().fold(0u8, |acc, (i, &val)| {
                acc | (val << (bits_per_index * i as u8))
            })
        })
        .collect()
}

pub struct SpriteSheetImage {
    pub(crate) pixels_per_byte: u8,
    pub(crate) width: u8,
    pub(crate) height: u8,
    pub(crate) palette: Vec<u8>,
    pub(crate) pixel_array: Vec<u8>,
}

impl SpriteSheetImage {
    pub fn load_spritesheet(file_path: String) -> SpriteSheetImage {
        // Read the file
        let file_contents = fs::read(file_path).expect("Failed to read file");

        let bmp = tinybmp::Bmp::<Rgb888>::from_slice(file_contents.as_slice()).unwrap();
        let color_map = color_map();
        let color_palette = derive_gametank_colors(bmp.as_raw().color_table().unwrap());

        let num_colors = color_palette.len();

        let bits_per_color = match num_colors {
            0..=2 => 1,  // Up to 2 colors can be represented with 1 bit each
            3..=4 => 2,  // Up to 4 colors need 2 bits each
            5..=16 => 4, // Up to 16 colors need 4 bits each
            _ => 8       // More than 16 colors will use 8 bits (1 byte) per color
        };

        let pixels_per_byte: u8 = 8 / bits_per_color;

        // map bmp pixels to indices
        let pixel_indices: Vec<u8> = bmp.pixels()
            .map(|pixel| {
                let gt_color = color_map.get(&pixel.1).unwrap();
                let idx = color_palette.iter().position(|c| c == gt_color).unwrap();
                idx as u8
            }).collect();

        let packed_pixels = pack_indices(pixel_indices, pixels_per_byte);

        let header = bmp.as_raw().header();

        let width = header.image_size.width as u8;
        let height = header.image_size.height as u8;
        let _pixel_array_size = packed_pixels.len();
        
        SpriteSheetImage {
            pixels_per_byte,
            width,
            height,
            palette: color_palette,
            pixel_array: packed_pixels,
        }
    }
}
